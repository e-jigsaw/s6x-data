{"id":"65782bdc7f7caf0023343268","title":"20231212","image":null,"created":1702374368,"updated":1702437562,"lines":[{"id":"65782bdc7f7caf0023343268","text":"20231212","created":1702374368,"updated":1702374368},{"id":"65782bdf4ade4d000013b2f8","text":"#1212","created":1702374368,"updated":1702374368},{"id":"65782bdf4ade4d000013b2f9","text":"","created":1702374368,"updated":1702374368},{"id":"657913fe4ade4d000013b302","text":"Cloudflare Worker で Google IAP の jwt ペイロードを検証する","created":1702433791,"updated":1702433812},{"id":"657914144ade4d000013b304","text":"\t[Cloudflare Access] 使えや!!という声が四面楚歌のように聞こえてくるが、まあ、テクニカルにはできるんで.....","created":1702433813,"updated":1702434405},{"id":"657914434ade4d000013b305","text":"\thttps://cloud.google.com/iap/docs/signed-headers-howto","created":1702433859,"updated":1702433888},{"id":"657914714ade4d000013b306","text":"\t[GCP] 側で設定して Cloudflare Worker にリクエストを流すようにすると request の headers に `x-goog-iap-jwt-assertion` として jwt のペイロードが含まって送られてくる","created":1702433905,"updated":1702433962},{"id":"657914aa4ade4d000013b307","text":"\t[Node.js] のコードでは `google-auth-library` に実際の検証コードがあるので node コンパチ環境ではこれを使うでいけるのだが、Worker には当然 WebCrypto 相当の API しか生えてないし、fs とかもないのでそのまま使うことはできない","created":1702433962,"updated":1702434051},{"id":"657915034ade4d000013b308","text":"\t仕方ないので `google-auth-library` を読み下してそれっぽいコードを実装した","created":1702434051,"updated":1702434076},{"id":"6579151c4ade4d000013b309","text":"\tJWK 形式の公開鍵は https://www.gstatic.com/iap/verify/public_key-jwk にあるのでこれを fetch してくる","created":1702434076,"updated":1702434106},{"id":"6579153a4ade4d000013b30a","text":"\tJWT はヘッダとペイロードとシグネチャの3セグあるかをバリデートする","created":1702434106,"updated":1702434141},{"id":"6579155e4ade4d000013b30b","text":"\tヘッダとペイロードは `JSON.parse(atob(seg[0]))` みたいな感じでデコードする","created":1702434142,"updated":1702434225},{"id":"657915bd4ade4d000013b30c","text":"\tヘッダに `kid` が入ってるので、jwk の `keys` から該当する cert を探してくる","created":1702434238,"updated":1702434266},{"id":"657915da4ade4d000013b30d","text":"\t見たところ [ES256] で署名されてるのでアルゴリズムには [ECDSA] を指定する","created":1702434266,"updated":1702434321},{"id":"657916114ade4d000013b30e","text":"\t\t無知なのでアレだけど、`importKey` は `{ name: 'ECDSA', namedCurve: 'P-256' }`、`verify` は `{ name: 'ECDSA', hash: { name: 'SHA-256' } }` をそれぞれ指定する","created":1702434322,"updated":1702434393},{"id":"6579165b4ade4d000013b30f","text":"\t`importKey` は何もしなくても jwk で取得できるので問題ないが、`verify` の方は引数が ArrayBuffer なので base64エンコード の文字列から起こすのが地味に面倒くさい","created":1702434395,"updated":1702436133},{"id":"65791d254ade4d000013b310","text":"\tとりあえずこれで検証自体はできるので、あとは iat と exp と iss と aud をそれぞれ検証すればよい","created":1702436133,"updated":1702436183},{"id":"65791d584ade4d000013b311","text":"\tworker => worker は service bindings で呼び出すにして、workers.dev を塞いでやれば IAP を通したリクエストだけが子 worker にやってくる状態がつくれる","created":1702436185,"updated":1702436258},{"id":"65791da24ade4d000013b312","text":"\tworker => pages は service bindigs ではつながらないので、pages.dev を fetch でつないでやるなどしないといけない","created":1702436259,"updated":1702436281},{"id":"65791dba4ade4d000013b313","text":"\t\tここのリクエストに事前共有の値をヘッダにくっつけてリクエストを送って、リクエストを受け取る pages function でリクエストのヘッダを検証して、ヘッダがついていれば200を返して、なければ401とすることで擬似的な制限が可能になる","created":1702436283,"updated":1702436525},{"id":"65791eac4ade4d000013b314","text":"\t\tただ、pages function を通らないアセット類に関してはガバガバなのでフルオープンになっちゃう","created":1702436525,"updated":1702436552},{"id":"65791ecd4ade4d000013b315","text":"\t\t\tAccess だとアセット類もちゃんと塞いでくれるので偉い","created":1702436558,"updated":1702436570},{"id":"65791edb4ade4d000013b316","text":"\t\t\tとはいえ現代のツールチェインを使ってるとだいたいアセットにはダイジェストがくっついてるので、攻撃したい人がドンズバで URL 当てないと引っ張ってこれないのでまあ妥協ラインとしてはそんなもんかなあと","created":1702436572,"updated":1702436630},{"id":"657922334ade4d000013b317","text":"\tあと worker => pages でつなぐ時は `POST` の body が ReadableStream として入ってきてはいるけど、pages の fetch の body としては使えないってことになってるっぽくて、一旦 body を worker の中で json なり formData なり確定させないといけない","created":1702437427,"updated":1702437508},{"id":"657922844ade4d000013b318","text":"\t\tこの時、formData だと headers の Content-Type に boundary が入ってて、headers をそのままパスしてると pages 側で formData として受け取れないので取り除いてやらないといけなかった","created":1702437508,"updated":1702437562},{"id":"657913fe4ade4d000013b303","text":"","created":1702433791,"updated":1702433791},{"id":"65782be04ade4d000013b2fa","text":"Storybook + msw + play function で test-runner でだけ msw のモックが効かない","created":1702374368,"updated":1702375002},{"id":"65782e5a4ade4d000013b2fd","text":"\tStorybook の play function が jest ベースから vitest ベースになっていよいよイイ感じになってきた","created":1702375003,"updated":1702375038},{"id":"65782e7d4ade4d000013b2fe","text":"\t\t余談だけど、next 環境で swc が有効になったのも嬉しい、体感でわかるぐらいビルドが速くなった気がする","created":1702375038,"updated":1702375074},{"id":"65782ea24ade4d000013b2ff","text":"\tで、play function で testing-library 絡めたテストを書いてると、やっぱり API リクエストをモックしたくなるよねってことで重い腰をあげて msw をいれた","created":1702375075,"updated":1702375202},{"id":"65782f244ade4d000013b300","text":"\t\t今までは react-query のキャッシュをモックして API リクエストのモック相当としていたんだけど、play 側から render の中を触れないので不便だなと","created":1702375205,"updated":1702375260},{"id":"65782f5c4ade4d000013b301","text":"\tmsw の storybook の plugin をいれたんだけど、ここは結構罠で msw は v2 だと動かなかった","created":1702375261,"updated":1702375368},{"id":"65782be04ade4d000013b2fb","text":"","created":1702374368,"updated":1702374368},{"id":"65782be04ade4d000013b2fc","text":"","created":1702374368,"updated":1702374368}]}